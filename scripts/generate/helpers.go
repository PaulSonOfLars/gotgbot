package main

import (
	"fmt"
	"strings"
	"text/template"
)

func generateHelpers(d APIDescription) error {
	helpers := strings.Builder{}
	helpers.WriteString(`
// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Regen by running 'go generate' in the repo root.

package gotgbot

`)

	for _, tgTypeName := range orderedTgTypes(d) {
		tgType := d.Types[tgTypeName]

		helper, err := generateHelperDef(d, tgType)
		if err != nil {
			return fmt.Errorf("failed to generate helpers for %s: %w", tgType.Name, err)
		}

		if helper == "" {
			continue
		}

		helpers.WriteString(helper)
	}

	return writeGenToFile(helpers, "gen_helpers.go")
}

type helperData struct {
	newName     string
	method      MethodDescription
	fields      map[string]string
	returnTypes []string
	defArgList  []string
	callArgList []string
	opts        string
}

func (d helperData) docs() string {
	return "\n// " + d.newName + " Helper method for Bot." + strings.Title(d.method.Name)
}

func getHelpers(d APIDescription, typeName string, typeFields []Field) ([]helperData, error) {
	receiver := receiver(typeName)
	if typeName == "InaccessibleMessage" {
		typeName = "Message"
	}

	var methods []helperData
	for _, methodName := range orderedMethods(d) {

		tgMethod := d.Methods[methodName]

		// Get list of fields which match the method types
		fieldMatches := getFieldsTypeMatches(typeName, typeFields, tgMethod.Fields)
		if len(fieldMatches) == 0 {
			continue
		}

		newMethodName, ok, err := getMethodFieldsSubtypeMatches(d, typeName, typeFields, tgMethod, fieldMatches)
		if err != nil {
			return nil, err
		}
		if !ok {
			continue
		}

		ret, err := tgMethod.GetReturnTypes(d)
		if err != nil {
			return nil, fmt.Errorf("failed to get return type for %s: %w", tgMethod.Name, err)
		}

		funcCallArgList, funcDefArgList, optsContent, err := generateHelperArguments(d, tgMethod, receiver, fieldMatches)
		if err != nil {
			return nil, err
		}

		methods = append(methods, helperData{
			newName:     newMethodName,
			method:      tgMethod,
			fields:      fieldMatches,
			returnTypes: ret,
			callArgList: funcCallArgList,
			defArgList:  funcDefArgList,
			opts:        optsContent,
		})
	}

	return methods, nil
}

func generateHelperDef(d APIDescription, tgType TypeDescription) (string, error) {
	if tgType.Name == tgTypeFile {
		return "", nil
	}
	if len(tgType.Subtypes) != 0 {
		// TODO: Generate common list of methods for all the child types
		return "", nil
	}

	helpers, err := getHelpers(d, tgType.Name, tgType.Fields)
	if err != nil {
		return "", err
	}

	helperDef := strings.Builder{}
	for _, helper := range helpers {
		helperDef.WriteString(helper.docs())

		err = helperFuncTmpl.Execute(&helperDef, helperFuncData{
			Receiver:     tgType.receiverName(),
			TypeName:     tgType.Name,
			HelperName:   helper.newName,
			ReturnType:   strings.Join(helper.returnTypes, ", "),
			FuncDefArgs:  strings.Join(helper.defArgList, ", "),
			Contents:     helper.opts,
			OptsName:     helper.method.optsName(),
			MethodName:   strings.Title(helper.method.Name),
			FuncCallArgs: strings.Join(helper.callArgList, ", "),
		})
		if err != nil {
			return "", fmt.Errorf("failed to execute template to generate %s helper method on %s: %w", helper.newName, tgType.Name, err)
		}
	}

	return helperDef.String(), nil
}

func hasFromChat(tgMethod MethodDescription) bool {
	hasFromChat := false

	for _, x := range tgMethod.Fields {
		if x.Name == "from_chat_id" {
			hasFromChat = true
			break
		}
	}
	return hasFromChat
}

func generateHelperArguments(d APIDescription, tgMethod MethodDescription, receiverName string, fields map[string]string) ([]string, []string, string, error) {
	var funcCallArgList []string
	optsContent := strings.Builder{}
	funcDefArgList := []string{"b *Bot"}
	hasOpts := false

	for _, mf := range tgMethod.Fields {
		hasOpts = hasOpts || !mf.Required

		prefType, err := mf.getPreferredType(d)
		if err != nil {
			return nil, nil, "", fmt.Errorf("failed to get preferred type for field %s of %s: %w", mf.Name, tgMethod.Name, err)
		}

		if fName, ok := fields[mf.Name]; ok {
			if !mf.Required {
				defaultValue := getDefaultTypeVal(d, prefType)
				optsContent.WriteString("\n	if opts." + snakeToTitle(mf.Name) + " == " + defaultValue + " {")
				if isPointer(prefType) {
					optsContent.WriteString("\n		opts." + snakeToTitle(mf.Name) + " = &" + receiverName + "." + snakeToTitle(fName))
				} else {
					optsContent.WriteString("\n		opts." + snakeToTitle(mf.Name) + " = " + receiverName + "." + snakeToTitle(fName))
				}
				optsContent.WriteString("\n	}")
				continue
			}

			funcCallArgList = append(funcCallArgList, receiverName+"."+snakeToTitle(fName))
			continue
		}

		if !mf.Required {
			continue
		}

		funcDefArgList = append(funcDefArgList, snakeToCamel(mf.Name)+" "+prefType)
		funcCallArgList = append(funcCallArgList, snakeToCamel(mf.Name))
	}

	funcDefArgList = append(funcDefArgList, "opts *"+tgMethod.optsName())
	funcCallArgList = append(funcCallArgList, "opts")

	return funcCallArgList, funcDefArgList, optsContent.String(), nil
}

func getMethodFieldsSubtypeMatches(d APIDescription, typeName string, typeFields []Field, tgMethod MethodDescription, fields map[string]string) (string, bool, error) {
	newMethodName := strings.Replace(tgMethod.Name, typeName, "", 1)
	fromChat := hasFromChat(tgMethod)

	for _, f := range typeFields {
		if f.Name == "reply_to_message" {
			// this subfield just causes confusion; we always want the message_id
			continue
		}

		for _, mf := range tgMethod.Fields {
			prefType, err := f.getPreferredType(d)
			if err != nil {
				return "", false, fmt.Errorf("failed to get preferred type for field %s of %s: %w", mf.Name, tgMethod.Name, err)
			}

			if isTgType(d, prefType) && f.Name+"_id" == mf.Name {
				newMethodName = strings.ReplaceAll(newMethodName, prefType, "")

				if fromChat && mf.Name == "chat_id" {
					fields["from_chat_id"] = f.Name + ".Id"
				} else {
					fields[mf.Name] = f.Name + ".Id" // Note: maybe not just assume ID field exists?
				}
			}
		}
	}
	return strings.Title(newMethodName), newMethodName != tgMethod.Name, nil
}

func getFieldsTypeMatches(typeName string, typeFields []Field, methodFields []Field) map[string]string {
	fields := map[string]string{}
	snakeTypeNameId := titleToSnake(typeName) + "_id"

	for _, f := range methodFields {
		if f.Name == snakeTypeNameId || f.Name == "id" {
			fields[snakeTypeNameId] = findIdField(typeFields, f.Name)
		}
	}
	return fields
}

func findIdField(typeFields []Field, methodFieldName string) string {
	// And iterate over all the type fields, to see if any match the method field name.
	for _, f := range typeFields {
		if methodFieldName == f.Name {
			return methodFieldName
		}
	}
	return "id" // we default to "id" if nothing else matches
}

var helperFuncTmpl = template.Must(template.New("helperFunc").Parse(helperFunc))

type helperFuncData struct {
	Receiver     string
	TypeName     string
	HelperName   string
	ReturnType   string
	FuncDefArgs  string
	Contents     string
	OptsName     string
	MethodName   string
	FuncCallArgs string
}

const helperFunc = `
func ({{.Receiver}} {{.TypeName}}) {{.HelperName}}({{.FuncDefArgs}}) ({{.ReturnType}}, error) {
	{{- if .Contents}}
		if opts == nil {
			opts = &{{.OptsName}}{}
		}
		{{.Contents}}

	{{end}}
	return b.{{.MethodName}}({{.FuncCallArgs}})
}
`
